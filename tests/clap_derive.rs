use cargo_generate::{GenerateArgs, TemplatePath, generate};
use std::env;
use std::fs;
use std::path::Path;
use std::time::{SystemTime, UNIX_EPOCH};

const SUBTEMPLATE: &str = "clap-derive";

#[test]
fn should_generate_clap_derive_template() {
    // Create a temp dir manually using system time to avoid conflicts
    let base_tmp = env::temp_dir();
    let unique_name = format!(
        "cargo_generate_test_{}",
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis()
    );
    let out_dir = base_tmp.join(unique_name);
    fs::create_dir(&out_dir).expect("failed to create temp output directory");

    // Locate the template path (e.g., <CRATE_ROOT>/templates/clap-derive)
    let template_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join(SUBTEMPLATE);

    // Name of the generated project
    let project_name = "example-project";

    // Define the values that would normally be prompted or come from defaults
    // These values reflect the defaults generated by your Rhai script based on 'my-new-app'
    let define_args = vec![
        "cli_name=example-project-cli".to_string(),
        "binary_name=example-project-cli".to_string(),
        "library_name=example-project".to_string(),
        "command=ep".to_string(),
        "display_name=Example Project".to_string(),
        "repository=itsame/example-project".to_string(),
        format!("license_year={}", 2025), // Use actual current year
        "license_holder=Jane Doe".to_string(), // Example author
    ];

    let args = GenerateArgs {
        allow_commands: true,
        template_path: TemplatePath {
            path: Some(template_dir.to_string_lossy().to_string()),
            // 'subfolder' is only used if 'template_dir' was a parent directory
            // of the actual template, and 'clap-derive' was a subfolder *within* it.
            // 'clap-derive' is the template root here
            subfolder: Some(SUBTEMPLATE.to_owned()),
            ..Default::default()
        },
        destination: Some(out_dir.clone()),
        silent: true,
        quiet: true,
        force: true,
        name: Some(project_name.into()),
        define: define_args,
        ..Default::default()
    };

    // Run the generator
    generate(args).expect("template generation failed");

    // Verify output
    let generated_path = out_dir.join(project_name);
    assert!(
        generated_path.exists(),
        "Generated project directory was not created"
    );

    let expected_lib_path = generated_path.join(project_name).join("src").join("lib.rs");
    let expected_bin_path = generated_path
        .join(format!("{}-cli", project_name))
        .join("src")
        .join("main.rs");

    let found_main_or_lib = expected_lib_path.exists() || expected_bin_path.exists();

    assert!(
        found_main_or_lib,
        "Neither expected lib.rs at {:?} nor main.rs at {:?} found in generated project",
        expected_lib_path, expected_bin_path
    );

    fs::remove_dir_all(&out_dir).expect("failed to clean up test directory");
}
